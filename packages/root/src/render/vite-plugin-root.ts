import path from 'path';
import glob from 'tiny-glob';
import {RootConfig} from '../core/config';
import {isDirectory, isJsFile} from '../core/fsutils';

const JSX_ELEMENTS_REGEX = /jsxs?\("(\w[\w-]+\w)"/g;
const HTML_ELEMENTS_REGEX = /<(\w[\w-]+\w)/g;

export interface RootPluginOptions {
  rootDir: string;
  rootConfig: RootConfig;
}

export function pluginRoot(options?: RootPluginOptions) {
  const elementsVirtualId = 'virtual:root-elements';
  const resolvedElementsVirtualId = '\0' + elementsVirtualId;

  const rootDir = options?.rootDir || process.cwd();
  const rootConfig = options?.rootConfig || {};
  const elementsDirs = [path.join(rootDir, 'elements')];
  const includeDirs = rootConfig.elements?.include || [];
  includeDirs.forEach((dirPath) => {
    const elementsDir = path.resolve(rootDir, dirPath);
    if (!elementsDir.startsWith(rootDir)) {
      throw new Error(
        `the elements dir (${dirPath}) should be relative to the project's root dir (${rootDir})`
      );
    }
    elementsDirs.push(elementsDir);
  });

  let elementMap: Record<string, string>;
  async function updateElementMap() {
    elementMap = {};
    await Promise.all(
      elementsDirs.map(async (dirPath: string) => {
        const dirExists = await isDirectory(dirPath);
        if (!dirExists) {
          return;
        }
        const files = await glob('**/*', {cwd: dirPath});
        files.forEach((file) => {
          const parts = path.parse(file);
          if (isJsFile(parts.base)) {
            const fullPath = path.join(dirPath, file);
            const moduleId = fullPath.slice(rootDir.length);
            elementMap[parts.name] = moduleId;
          }
        });
      })
    );
  }

  async function getElementImport(tagname: string): Promise<string | null> {
    if (!elementMap) {
      await updateElementMap();
    }
    if (tagname in elementMap) {
      return elementMap[tagname];
    }
    return null;
  }

  function isCustomElement(id: string) {
    if (!isJsFile(id)) {
      return false;
    }
    return elementsDirs.some((elementsDir) => {
      return id.startsWith(elementsDir);
    });
  }

  return {
    name: 'vite-plugin-root',

    resolveId(id: string) {
      if (id === elementsVirtualId) {
        return resolvedElementsVirtualId;
      }
      return null;
    },

    async load(id: string) {
      if (id === resolvedElementsVirtualId) {
        await updateElementMap();
        return `export const elementsMap = ${JSON.stringify(elementMap)}`;
      }
      return null;
    },

    async transform(src: string, id: string): Promise<any> {
      if (isCustomElement(id)) {
        const idParts = path.parse(id);
        const deps = new Set<string>();
        const tagnames = [
          ...src.matchAll(JSX_ELEMENTS_REGEX),
          ...src.matchAll(HTML_ELEMENTS_REGEX),
        ];
        for (const match of tagnames) {
          const tagname = match[1];
          // All custom elements should contain a dash.
          if (!tagname.includes('-')) {
            continue;
          }
          // Avoid circular deps.
          if (tagname === idParts.name) {
            continue;
          }
          deps.add(tagname);
        }
        const importUrls: string[] = [];
        await Promise.all(
          Array.from(deps).map(async (tagname) => {
            const importUrl = await getElementImport(tagname);
            if (importUrl) {
              importUrls.push(importUrl);
            }
          })
        );
        if (importUrls.length > 0) {
          const importLines = importUrls
            .map((url) => `import '${url}';`)
            .join('\n');
          const code = `${src}

// autogenerated by root:
${importLines}
`;
          return {code};
        }
        return null;
      }
      return null;
    },
  };
}
