import path from 'node:path';
import {ElementModule} from 'virtual:root-elements';
import {RootConfig} from '../core/config';
import {getElements} from '../core/elements';
import {isJsFile} from '../core/fsutils';

const JSX_ELEMENTS_REGEX = /jsxs?\("(\w[\w-]+\w)"/g;
const HTML_ELEMENTS_REGEX = /<(\w[\w-]+\w)/g;

export interface RootPluginOptions {
  rootConfig: RootConfig;
}

export function pluginRoot(options: RootPluginOptions) {
  const elementsVirtualId = 'virtual:root-elements';
  const resolvedElementsVirtualId = '\0' + elementsVirtualId;
  const rootConfig = options.rootConfig;

  let tagNameToElement: Record<string, ElementModule>;
  const customElementFiles: Set<string> = new Set();
  async function updateElementMap() {
    tagNameToElement = await getElements(rootConfig);
    customElementFiles.clear();
    Object.values(tagNameToElement).forEach((elementModule) => {
      customElementFiles.add(elementModule.filePath);
      customElementFiles.add(elementModule.realPath);
    });
  }

  async function getElementImport(tagname: string): Promise<string | null> {
    if (!tagNameToElement) {
      await updateElementMap();
    }
    if (tagname in tagNameToElement) {
      const elementModule = tagNameToElement[tagname];
      if (elementModule.filePath === elementModule.realPath) {
        return elementModule.src;
      }
      // TODO(stevenle): handle symlinked elements.
    }
    return null;
  }

  function isCustomElement(id: string) {
    if (!isJsFile(id)) {
      return false;
    }
    return customElementFiles.has(id);
  }

  return {
    name: 'vite-plugin-root',

    resolveId(id: string) {
      if (id === elementsVirtualId) {
        return resolvedElementsVirtualId;
      }
      return null;
    },

    async load(id: string) {
      if (id === resolvedElementsVirtualId) {
        await updateElementMap();
        return `export const elementsMap = ${JSON.stringify(tagNameToElement)}`;
      }
      return null;
    },

    async transform(src: string, id: string): Promise<any> {
      if (isCustomElement(id)) {
        await updateElementMap();
        const idParts = path.parse(id);
        const deps = new Set<string>();
        const tagnames = [
          ...src.matchAll(JSX_ELEMENTS_REGEX),
          ...src.matchAll(HTML_ELEMENTS_REGEX),
        ];
        for (const match of tagnames) {
          const tagname = match[1];
          // All custom elements should contain a dash.
          if (!tagname.includes('-')) {
            continue;
          }
          // Avoid circular deps.
          if (tagname === idParts.name) {
            continue;
          }
          deps.add(tagname);
        }
        const importUrls: string[] = [];
        await Promise.all(
          Array.from(deps).map(async (tagname) => {
            const importUrl = await getElementImport(tagname);
            if (importUrl) {
              importUrls.push(importUrl);
            }
          })
        );
        if (importUrls.length > 0) {
          const importLines = importUrls
            .map((url) => `import '/${url}';`)
            .join('\n');
          const code = `${src}

// autogenerated by root:
${importLines}
`;
          return {code};
        }
        return null;
      }
      return null;
    },
  };
}
