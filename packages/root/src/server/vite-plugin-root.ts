import path from 'path';
import glob from 'tiny-glob';
import {ViteDevServer} from 'vite';

const ELEMENTS_REGEX = /h\("(\w[\w-]+\w)"/g;

export interface RootPluginOptions {
  // Project directory.
  rootDir?: string;
}

export function pluginRoot(options?: RootPluginOptions) {
  const rootDir = options?.rootDir || process.cwd();
  let config: any;
  let server: ViteDevServer;
  let elementMap: Record<string, string>;

  async function updateElementMap() {
    elementMap = {};
    const files = await glob('./elements/**/*', {cwd: rootDir});
    files.forEach(file => {
      const parts = path.parse(file);
      if (isJsFile(parts.base)) {
        elementMap[parts.name] = `${rootDir}/${file}`;
      }
    });
  }

  async function getElementImport(tagName: string): Promise<string | null> {
    if (!elementMap) {
      await updateElementMap();
    }
    if (tagName in elementMap) {
      const filePath = elementMap[tagName];
      if (server && server.moduleGraph) {
        const moduleSet = server.moduleGraph.getModulesByFile(filePath);
        if (moduleSet && moduleSet.size > 0) {
          const module = moduleSet.values().next().value;
          return module.url;
        }
      }
    }
    return null;
  }

  return {
    name: 'vite-plugin-root',

    // TODO(stevenle): when the config is resolved, store a list of places to
    // find custom elements.
    configResolved(resolvedConfig: any) {
      config = resolvedConfig;
    },

    configureServer(_server: ViteDevServer) {
      server = _server;
    },

    async transform(src: string, id: string): Promise<any> {
      if (id.includes('/elements/') && isJsFile(id)) {
        const idParts = path.parse(id);
        const deps = new Set<string>();
        const elementsRe = ELEMENTS_REGEX;
        for (const match of src.matchAll(elementsRe)) {
          const tagName = match[1];
          // All custom elements should contain a dash.
          if (!tagName.includes('-')) {
            continue;
          }
          // Avoid circular deps.
          if (tagName === idParts.name) {
            continue;
          }
          deps.add(tagName);
        }
        const importUrls: string[] = [];
        await Promise.all(
          Array.from(deps).map(async tagName => {
            const importUrl = await getElementImport(tagName);
            if (importUrl) {
              importUrls.push(importUrl);
            }
          })
        );
        if (importUrls.length > 0) {
          const importLines = importUrls
            .map(url => `import '${url}';`)
            .join('\n');
          const code = `${src}

// autogenerated by root:
${importLines}
`;
          return {code};
        }
        return null;
      }
    },
  };
}

function isJsFile(file: string): boolean {
  return !!file.match(/\.(j|t)sx?$/);
}

export default pluginRoot;
