import {promises as fs} from 'node:fs';
import path from 'node:path';
import {fileURLToPath} from 'node:url';
import {loadRootConfig, viteSsrLoadModule} from '@blinkk/root/node';
import * as dom from 'dts-dom';

import {Field, Schema} from '../core/schema.js';

type ProjectModule = typeof import('../core/project.js');
const __dirname = path.dirname(fileURLToPath(import.meta.url));

export async function generateTypes() {
  const rootDir = process.cwd();
  const rootConfig = await loadRootConfig(rootDir, {command: 'root-cms'});
  const modulePath = path.resolve(__dirname, './project.js');
  const project = (await viteSsrLoadModule(
    rootConfig,
    modulePath
  )) as ProjectModule;
  const schemas = await project.getProjectSchemas();
  const outputPath = path.resolve(rootDir, 'root-cms.d.ts');
  await generateSchemaDts(outputPath, schemas);
  console.log('saved root-cms.d.ts!');
}

const TEMPLATE = `/* eslint-disable */
/** Root.js CMS types. This file is autogenerated. */

export interface RootCMSFile {
  src: string;
  width?: number;
  height?: number;
  alt?: string;
}

export type RootCMSImage = RootCMSFile;

export type RootCMSOneOf<T = any> = T;

export type RootCMSOneOfOption<T, Base> = Base & {_type: T};

export interface RootCMSRichTextBlock {
  type: string;
  data: any;
}

export interface RootCMSRichText {
  blocks: RootCMSRichTextBlock[];
}

export interface RootCMSReference {
  /** The id of the doc, e.g. "Pages/foo-bar". */
  id: string;
  /** The collection id of the doc, e.g. "Pages". */
  collection: string;
  /** The slug of the doc, e.g. "foo-bar". */
  slug: string;
}

export interface RootCMSDoc<Fields extends {}> {
  /** The id of the doc, e.g. "Pages/foo-bar". */
  id: string;
  /** The collection id of the doc, e.g. "Pages". */
  collection: string;
  /** The slug of the doc, e.g. "foo-bar". */
  slug: string;
  /** System-level metadata. */
  sys: {
    createdAt: number;
    createdBy: string;
    modifiedAt: number;
    modifiedBy: string;
    firstPublishedAt?: number;
    firstPublishedBy?: string;
    publishedAt?: number;
    publishedBy?: string;
    locales?: string[];
  };
  /** User-entered field values from the CMS. */
  fields?: Fields;
}`;

class DtsFormatter {
  /**
   * Field types defined in either `.schema.ts` files or used by `oneOf()`
   * fields.
   */
  fieldsTypes: Record<string, dom.InterfaceDeclaration> = {};

  /**
   * For `collections/*.schema.ts` files, output a corresponding "RootCMSDoc"
   * type. For example, `collections/BlogPosts.schema.ts` would output a type
   * called `BlogPostsDoc`.
   */
  docTypes: Record<string, dom.TypeAliasDeclaration> = {};

  /** Adds the types for a `.schema.ts` file to the `.d.ts` file. */
  addSchemaFile(fileId: string, schema: Schema) {
    const jsdoc = `Generated from \`${fileId}\`.`;
    const typeId = alphanumeric(path.parse(fileId).name.split('.')[0]);

    // Create a set for collecting oneOf types used in the file.
    const oneOfTypes: Record<string, dom.InterfaceDeclaration> = {};

    // For `Foo.schema.ts`, output a type called `FooFields`.
    const fieldsTypeId = `${typeId}Fields`;
    const fieldsType = dom.create.interface(
      fieldsTypeId,
      dom.DeclarationFlags.Export
    );
    fieldsType.jsDocComment = jsdoc;
    for (const field of schema.fields) {
      if (!field.id) {
        continue;
      }
      fieldsType.members.push(fieldProperty(field, {typeId, oneOfTypes}));
    }

    // Output the oneOf() types used by the file.
    for (const oneOfTypeId in oneOfTypes) {
      if (!this.fieldsTypes[fieldsTypeId]) {
        this.fieldsTypes[oneOfTypeId] = oneOfTypes[oneOfTypeId];
      }
    }

    // Output the `<Name>Fields` type defined by the file. Overwrite any
    // existing types defined previously since the .schema.ts file should take
    // precedence over any types defined via oneOf().
    this.fieldsTypes[fieldsTypeId] = fieldsType;

    // For `/collections/Foo.schema.ts` files, output a `FooDoc` type.
    if (fileId.startsWith('/collections/')) {
      const docTypeId = `${typeId}Doc`;
      const baseType = dom.create.namedTypeReference('RootCMSDoc');
      baseType.typeArguments.push(dom.create.namedTypeReference(fieldsTypeId));
      const docType = dom.create.alias(
        docTypeId,
        baseType,
        dom.DeclarationFlags.Export
      );
      docType.jsDocComment = jsdoc;
      this.docTypes[docTypeId] = docType;
    }
  }

  /** Generates the `.d.ts` output as a string. */
  toString(): string {
    const results = [TEMPLATE];

    const sortedFieldsTypes = Object.keys(this.fieldsTypes).sort();
    for (const fieldsTypeId of sortedFieldsTypes) {
      const fieldsType = this.fieldsTypes[fieldsTypeId];
      results.push(this.typeToString(fieldsType));

      const docTypeId = this.fieldsTypeToDocType(fieldsTypeId);
      const docType = this.docTypes[docTypeId];
      if (docType) {
        results.push(this.typeToString(docType));
      }
    }

    const output =
      results
        .join('\n\n')
        .replaceAll('/**  ', '/** ')
        .replaceAll('  */', ' */')
        .replace(/\r\n|\r|\n/g, '\n') + '\n';
    return output;
  }

  /**
   * Converts "<Name>Fields" to "<Name>Doc".
   */
  private fieldsTypeToDocType(fieldsTypeId: string): string {
    if (!fieldsTypeId.endsWith('Fields')) {
      throw new Error(`"${fieldsTypeId}" should be suffixed with "Fields"`);
    }
    const name = fieldsTypeId.slice(0, -6);
    return `${name}Doc`;
  }

  private typeToString(type: dom.TopLevelDeclaration): string {
    return this.reformatOutput(dom.emit(type, {singleLineJsDocComments: true}));
  }

  /**
   * Formats the output to Google style conventions, e.g. 2-space indents and
   * single quote strings.
   */
  private reformatOutput(input: string): string {
    const lines = input.trim().split('\n');
    const results: string[] = [];
    for (const line of lines) {
      const convertedLine = line.replace(/ {4}/g, '  ').replaceAll('"', "'");
      results.push(convertedLine);
    }
    return results.join('\n');
  }
}

/**
 * Generates a root-cms.d.ts file from the .schema.ts files in the project.
 */
export async function generateSchemaDts(
  outputPath: string,
  schemas: Record<string, Schema>
) {
  const dtsFormatter = new DtsFormatter();
  for (const fileId in schemas) {
    const schema = schemas[fileId];
    dtsFormatter.addSchemaFile(fileId, schema);
  }
  const output = dtsFormatter.toString();
  await fs.writeFile(outputPath, output, 'utf-8');
}

interface FieldPropertyOptions {
  /**
   * The id of the file being parsed, e.g. for "Pages.schema.ts" this would be
   * "Pages".
   */
  typeId: string;
  /**
   * A collection of the oneOf types used by the field.
   */
  oneOfTypes: Record<string, dom.InterfaceDeclaration>;
}

function fieldProperty(
  field: Field,
  options: FieldPropertyOptions
): dom.PropertyDeclaration {
  const prop = dom.create.property(
    field.id!,
    fieldType(field, options),
    dom.DeclarationFlags.Optional
  );
  const jsdoc = [];
  if (field.label) {
    if (field.help) {
      jsdoc.push(`${field.label}. ${field.help}`);
    } else {
      jsdoc.push(field.label);
    }
  }
  if (field.deprecated) {
    jsdoc.push('@deprecated');
  }
  if (jsdoc.length > 0) {
    prop.jsDocComment = jsdoc.join('\n');
  }
  return prop;
}

function fieldType(field: Field, options: FieldPropertyOptions): dom.Type {
  if (field.type === 'array') {
    return dom.type.array(fieldType(field.of, options));
  }
  if (field.type === 'boolean') {
    return dom.type.boolean;
  }
  if (field.type === 'date') {
    return dom.type.string;
  }
  if (field.type === 'datetime') {
    return dom.type.number;
  }
  if (field.type === 'file') {
    const fileType = dom.create.namedTypeReference('RootCMSFile');
    return fileType;
  }
  if (field.type === 'image') {
    const imageType = dom.create.namedTypeReference('RootCMSImage');
    return imageType;
  }
  if (field.type === 'multiselect') {
    return dom.type.array(dom.type.string);
  }
  if (field.type === 'oneof') {
    const oneOf = dom.create.namedTypeReference('RootCMSOneOf');
    if (field.types && Array.isArray(field.types)) {
      const unionTypes: dom.NamedTypeReference[] = [];
      field.types.forEach((schema: Schema | string) => {
        let typeName: string = '';
        if (typeof schema === 'string') {
          typeName = schema;
          return;
        } else if (schema?.name) {
          typeName = schema.name;
        }
        // The "name" property is required.
        if (!typeName) {
          return;
        }

        const cleanName = alphanumeric(typeName);
        const oneOfTypeId = `${cleanName}Fields`;

        // Add the oneOf type to the .d.ts file.
        if (typeof schema === 'object' && !options.oneOfTypes[oneOfTypeId]) {
          const oneOfTypeInterface = dom.create.interface(
            oneOfTypeId,
            dom.DeclarationFlags.Export
          );
          if (schema.description) {
            oneOfTypeInterface.jsDocComment = schema.description;
          }
          const oneOfTypeFields = schema.fields || [];
          oneOfTypeFields.forEach((f: Field) => {
            oneOfTypeInterface.members.push(fieldProperty(f, options));
          });
          options.oneOfTypes[oneOfTypeId] = oneOfTypeInterface;
        }

        const oneOfOption = dom.create.namedTypeReference('RootCMSOneOfOption');
        oneOfOption.typeArguments = [
          dom.type.stringLiteral(typeName),
          dom.create.namedTypeReference(oneOfTypeId),
        ];
        unionTypes.push(oneOfOption);
      });
      if (unionTypes.length > 0) {
        oneOf.typeArguments = [dom.create.union(unionTypes)];
      }
    }
    return oneOf;
  }
  if (field.type === 'reference') {
    const referenceType = dom.create.namedTypeReference('RootCMSReference');
    return referenceType;
  }
  if (field.type === 'references') {
    const referenceType = dom.create.namedTypeReference('RootCMSReference');
    return dom.type.array(referenceType);
  }
  if (field.type === 'richtext') {
    const richtextType = dom.create.namedTypeReference('RootCMSRichText');
    return richtextType;
  }
  if (field.type === 'select') {
    return dom.type.string;
  }
  if (field.type === 'string') {
    return dom.type.string;
  }
  if (field.type === 'object') {
    const subproperties = (field.fields || []).map((f) =>
      fieldProperty(f, options)
    );
    return dom.create.objectType(subproperties);
  }
  return dom.type.unknown;
}

/**
 * Removes non-alphanumeric chars from a string.
 */
function alphanumeric(input: string): string {
  return input.replace(/[^a-zA-Z0-9]/g, '');
}
