import {promises as fs} from 'node:fs';
import path from 'node:path';
import {fileURLToPath} from 'node:url';
import {loadRootConfig, viteSsrLoadModule} from '@blinkk/root/node';
import * as dom from 'dts-dom';

import {Field, Schema} from '../core/schema.js';

type ProjectModule = typeof import('../core/project.js');
const __dirname = path.dirname(fileURLToPath(import.meta.url));

export async function generateTypes() {
  const rootDir = process.cwd();
  const rootConfig = await loadRootConfig(rootDir, {command: 'root-cms'});
  const modulePath = path.resolve(__dirname, './project.js');
  const project = (await viteSsrLoadModule(
    rootConfig,
    modulePath
  )) as ProjectModule;
  const schemas = project.getProjectSchemas();
  const outputPath = path.resolve(rootDir, 'root-cms.d.ts');
  await generateSchemaDts(outputPath, schemas);
  console.log('saved root-cms.d.ts!');
}

const TEMPLATE = `/** Root.js CMS types. This file is autogenerated. */

export interface RootCMSFile {
  src: string;
  width?: number;
  height?: number;
  alt?: string;
}

export type RootCMSImage = RootCMSFile;

export type RootCMSOneOf<T = any> = T;

export interface RootCMSRichTextBlock {
  type: string;
  data: any;
}

export interface RootCMSRichText {
  blocks: RootCMSRichTextBlock[];
}

export interface RootCMSReference {
  /** The id of the doc, e.g. "Pages/foo-bar". */
  id: string;
  /** The collection id of the doc, e.g. "Pages". */
  collection: string;
  /** The slug of the doc, e.g. "foo-bar". */
  slug: string;
}

export interface RootCMSDoc<Fields extends {}> {
  /** The id of the doc, e.g. "Pages/foo-bar". */
  id: string;
  /** The collection id of the doc, e.g. "Pages". */
  collection: string;
  /** The slug of the doc, e.g. "foo-bar". */
  slug: string;
  /** System-level metadata. */
  sys: {
    createdAt: number;
    createdBy: string;
    modifiedAt: number;
    modifiedBy: string;
    firstPublishedAt?: number;
    firstPublishedBy?: string;
    publishedAt?: number;
    publishedBy?: string;
    locales?: string[];
  };
  /** User-entered field values from the CMS. */
  fields?: Fields;
}`;

/**
 * Generates a root-cms.d.ts file from the .schema.ts files in the project.
 */
export async function generateSchemaDts(
  outputPath: string,
  schemas: Record<string, Schema>
) {
  const results = [TEMPLATE];
  for (const fileId in schemas) {
    const schema = schemas[fileId];
    results.push(renderSchema(fileId, schema));
  }
  const output =
    results
      .join('\n\n')
      .replaceAll('/**  ', '/** ')
      .replaceAll('  */', ' */')
      .replace(/\r\n|\r|\n/g, '\n') + '\n';
  await fs.writeFile(outputPath, output, 'utf-8');
}

interface FieldPropertyOptions {
  /**
   * The id of the file being parsed, e.g. for "Pages.schema.ts" this would be
   * "Pages".
   */
  typeId: string;
  /**
   * A collection of the oneOf types used by the field.
   */
  oneOfTypes: Record<string, dom.InterfaceDeclaration>;
}

function fieldProperty(
  field: Field,
  options: FieldPropertyOptions
): dom.PropertyDeclaration {
  const prop = dom.create.property(
    field.id!,
    fieldType(field, options),
    dom.DeclarationFlags.Optional
  );
  const jsdoc = [];
  if (field.label) {
    if (field.help) {
      jsdoc.push(`${field.label}. ${field.help}`);
    } else {
      jsdoc.push(field.label);
    }
  }
  if (field.deprecated) {
    jsdoc.push('@deprecated');
  }
  if (jsdoc.length > 0) {
    prop.jsDocComment = jsdoc.join('\n');
  }
  return prop;
}

function fieldType(field: Field, options: FieldPropertyOptions): dom.Type {
  if (field.type === 'array') {
    return dom.type.array(fieldType(field.of, options));
  }
  if (field.type === 'boolean') {
    return dom.type.boolean;
  }
  if (field.type === 'date') {
    return dom.type.string;
  }
  if (field.type === 'datetime') {
    return dom.type.number;
  }
  if (field.type === 'file') {
    const fileType = dom.create.namedTypeReference('RootCMSFile');
    return fileType;
  }
  if (field.type === 'image') {
    const imageType = dom.create.namedTypeReference('RootCMSImage');
    return imageType;
  }
  if (field.type === 'multiselect') {
    return dom.type.array(dom.type.string);
  }
  if (field.type === 'oneof') {
    const oneOf = dom.create.namedTypeReference('RootCMSOneOf');
    if (field.types && Array.isArray(field.types)) {
      const unionTypes: dom.NamedTypeReference[] = [];
      field.types.forEach((schema: Schema) => {
        // The "name" property is required.
        if (!schema.name) {
          return;
        }

        const cleanName = alphanumeric(schema.name);
        const oneOfTypeId = `${options.typeId}_${cleanName}`;

        // Add the oneOf type to the .d.ts file as `{FileId}_{TypeName}`.
        if (!options.oneOfTypes[oneOfTypeId]) {
          const oneOfTypeInterface = dom.create.interface(
            oneOfTypeId,
            dom.DeclarationFlags.Export
          );
          oneOfTypeInterface.members.push(
            dom.create.property(
              '_type',
              dom.type.stringLiteral(schema.name),
              dom.DeclarationFlags.None
            )
          );
          const oneOfTypeFields = schema.fields || [];
          oneOfTypeFields.forEach((f: Field) => {
            oneOfTypeInterface.members.push(fieldProperty(f, options));
          });
          options.oneOfTypes[oneOfTypeId] = oneOfTypeInterface;
        }

        unionTypes.push(dom.create.namedTypeReference(oneOfTypeId));
      });
      if (unionTypes.length > 0) {
        oneOf.typeArguments = [dom.create.union(unionTypes)];
      }
    }
    return oneOf;
  }
  if (field.type === 'reference') {
    const referenceType = dom.create.namedTypeReference('RootCMSReference');
    return referenceType;
  }
  if (field.type === 'richtext') {
    const richtextType = dom.create.namedTypeReference('RootCMSRichText');
    return richtextType;
  }
  if (field.type === 'select') {
    return dom.type.string;
  }
  if (field.type === 'string') {
    return dom.type.string;
  }
  if (field.type === 'object') {
    const subproperties = (field.fields || []).map((f) =>
      fieldProperty(f, options)
    );
    return dom.create.objectType(subproperties);
  }
  return dom.type.unknown;
}

function renderSchema(fileId: string, schema: Schema): string {
  const jsdoc = `Generated from \`${fileId}\`.`;
  const typeId = alphanumeric(path.parse(fileId).name.split('.')[0]);

  // Create a set for collecting oneOf types used in the file.
  const oneOfTypes: Record<string, dom.InterfaceDeclaration> = {};

  // For `Foo.schema.ts`, output a type called `FooFields`.
  const fieldsInterface = `${typeId}Fields`;
  const fieldsType = dom.create.interface(
    fieldsInterface,
    dom.DeclarationFlags.Export
  );
  fieldsType.jsDocComment = jsdoc;
  for (const field of schema.fields) {
    if (!field.id) {
      continue;
    }
    fieldsType.members.push(fieldProperty(field, {typeId, oneOfTypes}));
  }

  const typesOutput: string[] = [];

  // Output all oneOf types used by the file.
  Object.values(oneOfTypes).forEach((oneOfTypeDef) => {
    oneOfTypeDef.jsDocComment = jsdoc;
    typesOutput.push(
      dom.emit(oneOfTypeDef, {singleLineJsDocComments: true}).trim()
    );
  });

  // Output the `FooFields` type.
  typesOutput.push(
    dom.emit(fieldsType, {singleLineJsDocComments: true}).trim()
  );

  // For `/collections/Foo.schema.ts` files, output a `FooDoc` type.
  if (fileId.startsWith('/collections/')) {
    const baseType = dom.create.namedTypeReference('RootCMSDoc');
    baseType.typeArguments.push(dom.create.namedTypeReference(fieldsInterface));
    const docType = dom.create.alias(
      `${typeId}Doc`,
      baseType,
      dom.DeclarationFlags.Export
    );
    docType.jsDocComment = jsdoc;
    const docTypeOutput = dom
      .emit(docType, {singleLineJsDocComments: true})
      .trim();
    typesOutput.push(docTypeOutput);
  }
  return reformatOutput(typesOutput.join('\n\n'));
}

/**
 * Formats the output to Google style conventions, e.g. 2-space indents and
 * single quote strings.
 */
function reformatOutput(input: string): string {
  const lines = input.split('\n');
  const results: string[] = [];
  for (const line of lines) {
    const convertedLine = line.replace(/ {4}/g, '  ').replaceAll('"', "'");
    results.push(convertedLine);
  }
  return results.join('\n');
}

/**
 * Removes non-alphanumeric chars from a string.
 */
function alphanumeric(input: string): string {
  return input.replace(/[^a-zA-Z0-9]/g, '');
}
